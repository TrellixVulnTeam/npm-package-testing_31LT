var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Managed } from './Managed';
import { EntityPartialUpdateBuilder } from '../partialupdate';
import { enumerable } from '../util/enumerable';
import { PersistentError } from '../error';
import { Enhancer } from './Enhancer';
export class Entity extends Managed {
    /**
     * The unique id of this object
     *
     * Sets the unique id of this object, if the id is not formatted as an valid id,
     * it will be used as the key component of the id has the same affect as setting the key
     *
     * @type string
     */
    get id() {
        return this._metadata.id;
    }
    set id(value) {
        if (this._metadata.id) {
            throw new Error(`The id can't be set twice: ${value}`);
        }
        const val = `${value}`;
        if (val.indexOf(`/db/${this._metadata.bucket}/`) === 0) {
            this._metadata.id = value;
        }
        else {
            this.key = value;
        }
    }
    /**
     * The unique key part of the id
     * When the key of the unique id is set an error will be thrown if an id is already set.
     * @type string
     */
    get key() {
        return this._metadata.key;
    }
    set key(value) {
        this._metadata.key = value;
    }
    /**
     * The version of this object
     * @type number
     * @readonly
     */
    get version() {
        return this._metadata.version;
    }
    /**
     * The object read/write permissions
     * @type Acl
     * @readonly
     */
    get acl() {
        this._metadata.throwUnloadedPropertyAccess('acl');
        return this._metadata.acl;
    }
    /**
     * Attach this object to the given db
     * @param db The db which will be used for future crud operations
     * @return
     */
    attach(db) {
        db.attach(this);
    }
    ready(doneCallback) {
        return this._metadata.ready().then(() => this).then(doneCallback);
    }
    /**
     * Saves the object. Inserts the object if it doesn't exists and updates the object if the object exist.
     * @param [options] The save options
     * @param [options.force=false] Force the save operation, the version will not be validated.
     * @param [options.depth=0] The object depth which will be saved. Depth 0 save this object only,
     * <code>true</code> saves the objects by reachability.
     * @param [options.refresh=false] Refresh the local object state from remote.
     * @param doneCallback Called when the operation succeed.
     * @param failCallback Called when the operation failed.
     * @return A Promise that will be fulfilled when the asynchronous operation completes.
     */
    save(options, doneCallback, failCallback) {
        if (typeof options === 'function') {
            return this.save({}, options, doneCallback);
        }
        return this._metadata.db.save(this, options).then(doneCallback, failCallback);
    }
    /**
     * Inserts a new object. Inserts the object if it doesn't exists and raise an error if the object already exist.
     * @param [options] The insertion options
     * @param [options.depth=0] The object depth which will be inserted. Depth 0 insert this object only,
     * <code>true</code> inserts objects by reachability.
     * @param [options.refresh=false] Refresh the local object state from remote.
     * @param doneCallback Called when the operation succeed.
     * @param failCallback Called when the operation failed.
     * @return A Promise that will be fulfilled when the asynchronous operation completes.
     * @method
     */
    insert(options, doneCallback, failCallback) {
        if (typeof options === 'function') {
            return this.insert({}, options, doneCallback);
        }
        return this._metadata.db.insert(this, options).then(doneCallback, failCallback);
    }
    /**
     * Updates an existing object
     *
     * Updates the object if it exists and raise an error if the object doesn't exist.
     *
     * @param [options] The update options
     * @param [options.force=false] Force the update operation,
     * the version will not be validated, only existence will be checked.
     * @param [options.depth=0] The object depth which will be updated. Depth 0 updates this object only,
     * <code>true</code> updates objects by reachability.
     * @param [options.refresh=false] Refresh the local object state from remote.
     * @param doneCallback Called when the operation succeed.
     * @param failCallback Called when the operation failed.
     * @return A Promise that will be fulfilled when the asynchronous operation completes.
     * @method
     */
    update(options, doneCallback, failCallback) {
        if (typeof options === 'function') {
            return this.update({}, options, doneCallback);
        }
        return this._metadata.db.update(this, options).then(doneCallback, failCallback);
    }
    /**
     * Resolves the referenced object in the specified depth
     *
     * Only unresolved objects will be loaded unless the refresh option is specified.
     *
     * Removed objects will be marked as removed.
     * @param [options] The load options
     * @param [options.depth=0] The object depth which will be loaded. Depth set to <code>true</code>
     * loads objects by reachability.
     * @param [options.refresh=false] Refresh the local object state from remote.
     * @param doneCallback Called when the operation succeed.
     * @param failCallback Called when the operation failed.
     * @return A Promise that will be fulfilled when the asynchronous operation completes.
     * @method
     */
    load(options, doneCallback, failCallback) {
        if (typeof options === 'function') {
            return this.load({}, options, doneCallback);
        }
        const opt = Object.assign({ local: true }, options);
        if (this.id === null) {
            throw new PersistentError("This object can't be loaded, it does have an id.");
        }
        return this._metadata.db.load(this.id, undefined, opt).then(doneCallback, failCallback);
    }
    /**
     * Deletes an existing object
     *
     * @param [options] The remove options
     * @param [options.force=false] Force the remove operation, the version will not be validated.
     * @param [options.depth=0] The object depth which will be removed. Depth 0 removes this object only,
     * <code>true</code> removes objects by reachability.
     * @param doneCallback Called when the operation succeed.
     * @param failCallback Called when the operation failed.
     * @return A Promise that will be fulfilled when the asynchronous operation completes.
     * @method
     */
    delete(options, doneCallback, failCallback) {
        if (typeof options === 'function') {
            return this.delete({}, options, doneCallback);
        }
        return this._metadata.db.delete(this, options).then(doneCallback, failCallback);
    }
    /**
     * Saves the object and repeats the operation if the object is out of date
     *
     * In each pass the callback will be called. Ths first parameter of the callback is the entity and the second one
     * is a function to abort the process.
     *
     * @param cb Will be called in each pass
     * @param doneCallback Called when the operation succeed.
     * @param failCallback Called when the operation failed.
     * @return A Promise that will be fulfilled when the asynchronous operation completes.
     * @method
     */
    optimisticSave(cb, doneCallback, failCallback) {
        return this._metadata.db.optimisticSave(this, cb).then(doneCallback, failCallback);
    }
    attr() {
        throw new Error('Attr is not yet implemented.');
    }
    /**
     * Validates the entity by using the validation code of the entity type
     *
     * @return Contains the result of the Validation
     * @method
     */
    validate() {
        return this._metadata.db.validate(this);
    }
    /**
     * Starts a partial update on this entity
     *
     * @param operations initial operations which should be executed
     * @return
     */
    partialUpdate(operations) {
        return new EntityPartialUpdateBuilder(this, operations);
    }
    /**
     * Get all objects which refer to this object
     *
     * @param [options] Some options to pass
     * @param [options.classes] An array of class names to filter for, null for no filter
     * @return A promise resolving with an array of all referencing objects
     * @method
     */
    getReferencing(options) {
        const { db } = this._metadata;
        const references = this._metadata.type.getReferencing(db, options);
        // Query all possibly referencing objects
        const allResults = Array.from(references).map(([ref, attrs]) => {
            // Create query for given entity
            const qb = db.createQueryBuilder(ref.typeConstructor);
            // Add term for each attribute
            const terms = [];
            attrs.forEach((attr) => {
                terms.push(qb.equal(attr, this));
            });
            // If more than one term, put everything in a disjunction
            const query = terms.length === 1 ? terms[0] : qb.or(terms);
            return query.resultList();
        });
        return Promise.all(allResults).then((results) => (
        // Filter out all objects which did not match
        results.filter((result) => !!result.length))).then((results) => (
        // Flat the array of results
        Array.prototype.concat.apply([], results)));
    }
    /**
     * Returns this object identifier or the baqend type of this object
     * @return the object id or type whatever is available
     */
    toString() {
        const type = Enhancer.getBaqendType(this.constructor);
        return this.id || type.ref;
    }
    /**
     * Converts the object to an JSON-Object
     * @param [options=false] to json options by default excludes the metadata
     * @param [options.excludeMetadata=false] Excludes the metadata form the serialized json
     * @param [options.depth=0] Includes up to depth referenced objects into the serialized json
     * @return JSON-Object
     * @method
     */
    toJSON(options) {
        // JSON.stringify calls toJSON with the parent key as the first argument.
        // Therefore ignore all unknown option types.
        let opt = options;
        if (typeof opt === 'boolean') {
            opt = {
                excludeMetadata: opt,
            };
        }
        if (typeof opt !== 'object') {
            opt = {};
        }
        const state = this._metadata;
        return state.type.toJsonValue(state, this, opt);
    }
}
__decorate([
    enumerable(true)
], Entity.prototype, "id", null);
__decorate([
    enumerable(false)
], Entity.prototype, "key", null);
__decorate([
    enumerable(true)
], Entity.prototype, "version", null);
__decorate([
    enumerable(true)
], Entity.prototype, "acl", null);
__decorate([
    enumerable(false)
], Entity.prototype, "attach", null);
__decorate([
    enumerable(false)
], Entity.prototype, "ready", null);
__decorate([
    enumerable(false)
], Entity.prototype, "save", null);
__decorate([
    enumerable(false)
], Entity.prototype, "insert", null);
__decorate([
    enumerable(false)
], Entity.prototype, "update", null);
__decorate([
    enumerable(false)
], Entity.prototype, "load", null);
__decorate([
    enumerable(false)
], Entity.prototype, "delete", null);
__decorate([
    enumerable(false)
], Entity.prototype, "optimisticSave", null);
__decorate([
    enumerable(false)
], Entity.prototype, "attr", null);
__decorate([
    enumerable(false)
], Entity.prototype, "validate", null);
__decorate([
    enumerable(false)
], Entity.prototype, "partialUpdate", null);
__decorate([
    enumerable(false)
], Entity.prototype, "getReferencing", null);
__decorate([
    enumerable(false)
], Entity.prototype, "toString", null);
__decorate([
    enumerable(false)
], Entity.prototype, "toJSON", null);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRW50aXR5LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vbGliL2JpbmRpbmcvRW50aXR5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFDcEMsT0FBTyxFQUFFLDBCQUEwQixFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDOUQsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQ2hELE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxVQUFVLENBQUM7QUFLM0MsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLFlBQVksQ0FBQztBQVF0QyxNQUFNLE9BQU8sTUFBTyxTQUFRLE9BQU87SUFtQmpDOzs7Ozs7O09BT0c7SUFFSCxJQUFJLEVBQUU7UUFDSixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDO0lBQzNCLENBQUM7SUFFRCxJQUFJLEVBQUUsQ0FBQyxLQUFvQjtRQUN6QixJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxFQUFFO1lBQ3JCLE1BQU0sSUFBSSxLQUFLLENBQUMsOEJBQThCLEtBQUssRUFBRSxDQUFDLENBQUM7U0FDeEQ7UUFFRCxNQUFNLEdBQUcsR0FBRyxHQUFHLEtBQUssRUFBRSxDQUFDO1FBQ3ZCLElBQUksR0FBRyxDQUFDLE9BQU8sQ0FBQyxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDdEQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLEdBQUcsS0FBSyxDQUFDO1NBQzNCO2FBQU07WUFDTCxJQUFJLENBQUMsR0FBRyxHQUFHLEtBQUssQ0FBQztTQUNsQjtJQUNILENBQUM7SUFFRDs7OztPQUlHO0lBRUgsSUFBSSxHQUFHO1FBQ0wsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQztJQUM1QixDQUFDO0lBRUQsSUFBSSxHQUFH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