var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var _a;
import { PersistentError } from '../error';
import { Acl } from '../Acl';
import { uuid, trailingSlashIt, } from '../util';
import * as message from '../message';
import { StatusCode, } from '../connector';
const FILE_BUCKET = '/file';
const FILE_BUCKET_LENGTH = FILE_BUCKET.length;
const ID = Symbol('Id');
const METADATA = Symbol('Metadata');
const DATA = Symbol('Data');
/**
 * Creates a file object, which represents one specific file reference.
 * This File object can afterwards be used to up- and download the file contents or to retrieves and change the files
 * metadata.
 *
 * The file data can be uploaded and downloaded as:
 *
 *  <table class="table">
 *   <tr>
 *     <th>type</th>
 *     <th>JavaScript type</th>
 *     <th>Description</th>
 *   </tr>
 *   <tr>
 *     <td>'arraybuffer'</td>
 *     <td>ArrayBuffer</td>
 *     <td>The content is represented as a fixed-length raw binary data buffer</td>
 *   </tr>
 *   <tr>
 *     <td>'blob'</th>
 *     <td>Blob</td>
 *     <td>The content is represented as a simple blob</td>
 *   </tr>
 *   <tr>
 *     <td>'json'</td>
 *     <td>object|array|string</td>
 *     <td>The file content is represented as json</td>
 *   </tr>
 *   <tr>
 *     <td>'text'</td>
 *     <td>string</td>
 *     <td>The file content is represented through the string</td>
 *   </tr>
 *   <tr>
 *     <td>'base64'</td>
 *     <td>string</td>
 *     <td>The file content as base64 encoded string</td>
 *   </tr>
 *   <tr>
 *     <td>'data-url'</td>
 *     <td>string</td>
 *     <td>A data url which represents the file content</td>
 *   </tr>
 * </table>
 *
 */
export class File {
    /**
     * Creates a new file object which represents a file at the given id. Data which is provided to the constructor will
     * be uploaded by invoking {@link upload()}
     * @param fileOptions The fileOptions used to create a new file object, or just the id of the file
     */
    constructor(fileOptions) {
        /**
         * The database connection to use
         */
        this.db = null; // is lazy initialized and never null
        this[_a] = null;
        // Is fileOptions just an id?
        const opt = typeof fileOptions === 'string' ? { id: fileOptions } : (fileOptions || {});
        if (opt.id) {
            // Check validity of id
            const nameSeparator = opt.id.indexOf('/', '/file/'.length);
            if (nameSeparator === -1 || opt.id.indexOf('/file/') !== 0) {
                throw new Error(`Invalid file reference ${opt.id}`);
            }
            this[ID] = opt.id;
        }
        else {
            this[ID] = this.createIdFromOptions(opt);
        }
        // Assign metadata
        this.setDataOptions(opt);
        this.isFolder = this.id.charAt(this.id.length - 1) === '/';
    }
    /**
     * The complete id of the file, including folder and name
     */
    get id() {
        return this[ID];
    }
    // @ts-ignore
    get url() {
        throw new Error('This method is removed. Use the asynchronous File.createURL() method instead.');
    }
    /**
     * The name of the file
     */
    get name() {
        return this.id.substring(this.id.lastIndexOf('/', this.id.length - 2) + 1);
    }
    /**
     * The mimeType of the file, only accessible after fetching the metadata or downloading/uploading/providing the file
     */
    get mimeType() {
        if (this.isFolder) {
            throw new Error('A folder has no mimeType');
        }
        this.checkAvailable();
        return this[METADATA].mimeType;
    }
    /**
     * The current file acl, only accessible after fetching the metadata or downloading/uploading/providing the file
     */
    get acl() {
        this.checkAvailable();
        return this[METADATA].acl;
    }
    /**
     * The last modified date of the file, only accessible after fetching the metadata
     * or downloading/uploading/providing the eTag
     */
    get lastModified() {
        if (this.isFolder) {
            throw new Error('A folder has no lastModified');
        }
        this.checkAvailable();
        return this[METADATA].lastModified;
    }
    /**
     * The creation date of the file, only accessible after fetching the metadata
     * or downloading/uploading/providing the eTag
     */
    get createdAt() {
        if (this.isFolder) {
            throw new Error('A folder has no creation date');
        }
        this.checkAvailable();
        return this[METADATA].createdAt;
    }
    /**
     * The eTag of the file, only accessible after fetching the metadata or downloading/uploading/providing the file
     */
    get eTag() {
        if (this.isFolder) {
            throw new Error('A folder has no eTag');
        }
        this.checkAvailable();
        return this[METADATA].eTag;
    }
    /**
     * The custom headers of the file, only accessible after fetching the metadata or downloading/uploading/providing
     * the file
     */
    get headers() {
        if (this.isFolder) {
            throw new Error('A folder has no custom headers');
        }
        this.checkAvailable();
        return this[METADATA].headers;
    }
    /**
     * The size of the file, only accessible after fetching the metadata or downloading/uploading/providing the file
     */
    get size() {
        if (this.isFolder) {
            throw new Error('A folder has no size');
        }
        this.checkAvailable();
        return this[METADATA].size;
    }
    /**
     * The root bucket of this file
     */
    get bucket() {
        return this.id.substring(FILE_BUCKET_LENGTH + 1, this.id.indexOf('/', FILE_BUCKET_LENGTH + 1));
    }
    /**
     * The full path under the bucket of this file
     */
    get key() {
        return this.id.substring(this.id.indexOf('/', FILE_BUCKET_LENGTH + 1) + 1);
    }
    /**
     * The full path of the file.
     */
    get path() {
        return this.id.substring(FILE_BUCKET_LENGTH);
    }
    /**
     * The parent folder of the file.
     */
    get parent() {
        return this.id.substring(FILE_BUCKET_LENGTH, this.id.lastIndexOf('/', this.id.length - 2));
    }
    /**
     * Indicates if the metadata are loaded.
     */
    get isMetadataLoaded() {
        return !!this[METADATA];
    }
    /**
     * Parses an E-Tag header
     * @param eTag The E-Tag to parse or something falsy
     * @return Returns the parsed E-Tag or null, if it could not be parsed
     */
    static parseETag(eTag) {
        if (!eTag) {
            return null;
        }
        const match = eTag.match(/^(?:[wW]\/)?["'](.*)["']$/);
        if (!match) {
            return null;
        }
        return match[1];
    }
    /**
     * The fully url to the file, can be directly used to link the file, i.e. in link tags ot image sources
     * @param authorize - Authorize the the link with an temporary token, to give authorized access to this protected
     * resource default false if the root bucket is www, true otherwise
     * @return A url with an optional token, to give direct access o the linked resource
     */
    createURL(authorize) {
        if (this.isFolder) {
            throw new Error('Url can not be created for folders.');
        }
        return this.db.createURL(this.id, typeof authorize === 'boolean' ? authorize : this.bucket !== 'www');
    }
    /**
     * Uploads the file content which was provided in the constructor or by uploadOptions.data
     * @param uploadOptions The upload options
     * @param [uploadOptions.force=false] force the upload and overwrite any existing files without validating
     * it
     * @param [uploadOptions.progress] listen to progress changes during upload
     * @param doneCallback The callback is invoked after the upload succeed successfully
     * @param failCallback The callback is invoked if any error is occurred
     * @return A promise which will be fulfilled with this file object where the metadata is updated
     */
    upload(uploadOptions, doneCallback, failCallback) {
        var _b;
        const opt = uploadOptions || {};
        if (this.isFolder) {
            throw new Error('A folder cannot be uploaded');
        }
        this.setDataOptions(opt);
        const uploadMessage = new message.UploadFile(this.bucket, this.key)
            .entity(this[DATA].data, (_b = this[DATA]) === null || _b === void 0 ? void 0 : _b.type);
        const meta = this[METADATA];
        if (meta) {
            uploadMessage.acl(meta.acl);
            uploadMessage.contentLength(meta.size);
            uploadMessage.mimeType(meta.mimeType);
            uploadMessage.customHeaders(meta.headers);
        }
        uploadMessage.progress(opt.progress || null);
        this.conditional(uploadMessage, opt);
        this.db.addToBlackList(this.id);
        return this.db.send(uploadMessage).then((response) => {
            this[DATA] = null;
            this.fromJSON(response.entity);
            return this;
        }).then(doneCallback, failCallback);
    }
    /**
     * Download a file and providing it in the requested type
     * @param downloadOptions The download options
     * @param downloadOptions.type="blob" The type used to provide the file
     * @param downloadOptions.refresh=false Indicates to make a revalidation request and not use the cache
     * @param doneCallback The callback is invoked after the download succeed
     * successfully
     * @param failCallback The callback is invoked if any error is occurred
     * @return A promise which will be fulfilled with the downloaded file content
     */
    download(downloadOptions, doneCallback, failCallback) {
        const opt = downloadOptions || {};
        if (this.isFolder) {
            throw new Error('A folder cannot be downloaded');
        }
        const type = opt.type || 'blob';
        const downloadMessage = new message.DownloadFile(this.bucket, this.key)
            .responseType(type);
        this.db.ensureCacheHeader(this.id, downloadMessage, opt.refresh);
        return this.db.send(downloadMessage).then((response) => {
            this.db.addToWhiteList(this.id);
            this.fromHeaders(response.headers);
            return response.entity;
        }, (e) => {
            if (e.status === StatusCode.OBJECT_NOT_FOUND) {
                return null;
            }
            throw e;
        }).then(doneCallback, failCallback);
    }
    /**
     * Deletes a file
     * @param deleteOptions The delete options
     * @param deleteOptions.force=false force the deletion without verifying any version
     * @param doneCallback The callback is invoked after the deletion succeed successfully
     * @param failCallback The callback is invoked if any error is occurred
     * @return A promise which will be fulfilled with this file object,
     * or with a list of all deleted files, if this file is an folder
     */
    delete(deleteOptions, doneCallback, failCallback) {
        const opt = deleteOptions || {};
        const deleteMessage = new message.DeleteFile(this.bucket, this.key);
        this.conditional(deleteMessage, opt);
        if (!this.isFolder) {
            this.db.addToBlackList(this.id);
        }
        return this.db.send(deleteMessage).then((response) => {
            if (!this.isFolder) {
                return this;
            }
            return response.entity.map((fileId) => new this.db.File(fileId));
        }).then(doneCallback, failCallback);
    }
    /**
     * Creates the file id from given options.
     * @param fileOptions
     * @return
     */
    createIdFromOptions(fileOptions) {
        var _b;
        let path;
        if (fileOptions.path) {
            path = fileOptions.path;
        }
        else {
            const parent = trailingSlashIt(fileOptions.parent || '/www');
            if (parent.length < 3) {
                throw new Error(`Invalid parent name: ${parent}`);
            }
            const name = fileOptions.name || ((_b = fileOptions === null || fileOptions === void 0 ? void 0 : fileOptions.data) === null || _b === void 0 ? void 0 : _b.name) || uuid();
            path = parent + name;
        }
        // Add leading slash if missing
        if (path.charAt(0) !== '/') {
            path = `/${path}`;
        }
        // Check path validity
        if (path.indexOf('//') !== -1 || path.length < 3) {
            throw new Error(`Invalid path: ${path}`);
        }
        return FILE_BUCKET + path;
    }
    /**
     * Makes the given message a conditional request based on the file metadata
     * @param msg The message to make conditional
     * @param options additional request options
     * @param options.force=false Force the request operation by didn't make it conditional
     */
    conditional(msg, options) {
        if (options.force) {
            return;
        }
        const meta = this[METADATA];
        if (!meta || (!meta.lastModified && !meta.eTag)) {
            msg.ifNoneMatch('*');
            return;
        }
        msg.ifUnmodifiedSince(meta.lastModified);
        msg.ifMatch(meta.eTag);
    }
    /**
     * Gets the file metadata of a file
     * @param options The load metadata options
     * @param [options.refresh=false] Force a revalidation while fetching the metadata
     * @param doneCallback The callback is invoked after the metadata is fetched
     * @param failCallback The callback is invoked if any error has occurred
     * @return A promise which will be fulfilled with this file
     */
    loadMetadata(options, doneCallback, failCallback) {
        const opt = options || {};
        if (this.isFolder) {
            throw new Error('A folder has no mata data.');
        }
        const msg = new message.GetFileMetadata(this.bucket, this.key);
        this.db.ensureCacheHeader(this.id, msg, opt.refresh);
        return this.db.send(msg).then((response) => {
            // do not white list the file, because head-request does not revalidate the cache.
            this.fromHeaders(response.headers);
            return this;
        }, (e) => {
            if (e.status === StatusCode.OBJECT_NOT_FOUND) {
                return null;
            }
            throw e;
        }).then(doneCallback, failCallback);
    }
    /**
     * Updates the mata data of this file.
     * @param options The save metadata options
     * @param [options.force=false] force the update and overwrite the existing metadata without validating it
     * @param doneCallback The callback is invoked after the metadata is saved
     * @param failCallback The callback is invoked if any error has occurred
     * @return A promise which will be fulfilled with this file
     */
    saveMetadata(options, doneCallback, failCallback) {
        const opt = options || {};
        const json = this.toJSON();
        const msg = new message.UpdateFileMetadata(this.bucket, this.key)
            .entity(json);
        this.conditional(msg, opt);
        return this.db.send(msg).then((response) => {
            this.fromJSON(response.entity);
            return this;
        }).then(doneCallback, failCallback);
    }
    /**
     * Validates and sets the file metadata based on the given options
     * @param options
     * @private
     */
    setDataOptions(options) {
        const { data, type } = options, metadata = __rest(options, ["data", "type"]);
        if (!data) {
            return;
        }
        // Set data
        this[DATA] = { type, data };
        const mimeType = this.guessMimeType(options) || undefined;
        this.fromJSON(Object.assign(Object.assign({}, metadata), { mimeType }));
    }
    /**
     * Gets the MIME type of given file options.
     * @param options
     * @return Returns the guessed MIME type or null, if it could not be guessed.
     * @private
     */
    guessMimeType(options) {
        const { mimeType } = options;
        if (mimeType) {
            return mimeType;
        }
        if (typeof Blob !== 'undefined' && options.data instanceof Blob) {
            return options.data.type;
        }
        if (options.type === 'data-url' && typeof options.data === 'string') {
            const match = options.data.match(/^data:(.+?)(;base64)?,.*$/);
            return match && match[1];
        }
        return null;
    }
    /**
     * @param headers
     */
    fromHeaders(headers) {
        this.fromJSON({
            eTag: File.parseETag(headers.etag),
            lastModified: headers['last-modified'],
            createdAt: headers['baqend-created-at'],
            mimeType: headers['content-type'],
            acl: headers['baqend-acl'] && JSON.parse(headers['baqend-acl']),
            size: +headers['baqend-size'],
            headers: headers['baqend-custom-headers'] && JSON.parse(headers['baqend-custom-headers']),
        });
    }
    /**
     * Deserialize the given JSON file metadata back to this file instance
     *
     * If the JSON object contains an ID, it must match with this file ID, otherwise an exception is thrown.
     *
     * @param json The json to deserialize
     */
    fromJSON(json) {
        const { id } = json;
        if (id && this.id !== id) {
            throw new Error(`This file id ${this.id} does not match the given json id ${id}`);
        }
        const meta = this[METADATA] || {};
        let acl;
        if (json.acl instanceof Acl) {
            acl = json.acl;
        }
        else {
            acl = meta.acl || new Acl();
            if (json.acl) {
                acl.fromJSON(json.acl);
            }
        }
        // keep last known lastModified, createdAt, eTag and headers
        this[METADATA] = Object.assign(Object.assign({}, this[METADATA]), { mimeType: json.mimeType, lastModified: (json.lastModified && new Date(json.lastModified)) || meta.lastModified, createdAt: (json.createdAt && new Date(json.createdAt)) || meta.createdAt, eTag: json.eTag || meta.eTag, acl, size: typeof json.size === 'number' ? json.size : json.contentLength, headers: json.headers || meta.headers || {} });
    }
    /**
     * Serialize the file metadata of this object to json
     * @return The serialized file metadata as json
     */
    toJSON() {
        var _b;
        this.checkAvailable();
        const meta = this[METADATA];
        return {
            id: this.id,
            mimeType: meta.mimeType,
            eTag: meta.eTag,
            acl: (_b = meta.acl) === null || _b === void 0 ? void 0 : _b.toJSON(),
            size: meta.size,
            lastModified: meta.lastModified && meta.lastModified.toISOString(),
            createdAt: meta.createdAt && meta.createdAt.toISOString(),
            headers: meta.headers,
        };
    }
    /**
     * Checks whenever metadata are already loaded of the file, throws an error otherwise
     * @return
     */
    checkAvailable() {
        if (!this.isMetadataLoaded) {
            throw new PersistentError(`The file metadata of ${this.id} is not available.`);
        }
    }
}
_a = DATA;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRmlsZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9iaW5kaW5nL0ZpbGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLFVBQVUsQ0FBQztBQUMzQyxPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sUUFBUSxDQUFDO0FBQzdCLE9BQU8sRUFDTCxJQUFJLEVBQUUsZUFBZSxHQUV0QixNQUFNLFNBQVMsQ0FBQztBQUNqQixPQUFPLEtBQUssT0FBTyxNQUFNLFlBQVksQ0FBQztBQUN0QyxPQUFPLEVBQ3NCLFVBQVUsR0FDdEMsTUFBTSxjQUFjLENBQUM7QUFJdEIsTUFBTSxXQUFXLEdBQUcsT0FBTyxDQUFDO0FBQzVCLE1BQU0sa0JBQWtCLEdBQUcsV0FBVyxDQUFDLE1BQU0sQ0FBQztBQUU5QyxNQUFNLEVBQUUsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDeEIsTUFBTSxRQUFRLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0FBQ3BDLE1BQU0sSUFBSSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztBQXdFNUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTZDRztBQUNILE1BQU0sT0FBTyxJQUFJO0lBcUpmOzs7O09BSUc7SUFDSCxZQUFZLFdBQXdCO1FBcEpwQzs7V0FFRztRQUNJLE9BQUUsR0FBa0IsSUFBVyxDQUFDLENBQUMscUNBQXFDO1FBTXJFLFFBQU0sR0FBb0IsSUFBSSxDQUFDO1FBNElyQyw2QkFBNkI7UUFDN0IsTUFBTSxHQUFHLEdBQUcsT0FBTyxXQUFXLEtBQUssUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxXQUFXLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLElBQUksRUFBRSxDQUFDLENBQUM7UUFFeEYsSUFBSSxHQUFHLENBQUMsRUFBRSxFQUFFO1lBQ1YsdUJBQXVCO1lBQ3ZCLE1BQU0sYUFBYSxHQUFHLEdBQUcsQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDM0QsSUFBSSxhQUFhLEtBQUssQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUFFO2dCQUMxRCxNQUFNLElBQUksS0FBSyxDQUFDLDBCQUEwQixHQUFHLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQzthQUNyRDtZQUVELElBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLENBQUMsRUFBRSxDQUFDO1NBQ25CO2FBQU07WUFDTCxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQzFDO1FBRUQsa0JBQWtCO1FBQ2xCLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDekIsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsS0FBSyxHQUFHLENBQUM7SUFDN0QsQ0FBQztJQTVKRDs7T0FFRztJQUNILElBQUksRUFBRTtRQUNKLE9BQU8sSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ2xCLENBQUM7SUFFRCxhQUFhO0lBQ2IsSUFBSSxHQUFHO1FBQ0wsTUFBTSxJQUFJLEtBQUssQ0FBQywrRUFBK0UsQ0FBQyxDQUFDO0lBQ25HLENBQUM7SUFFRDs7T0FFRztJQUNILElBQUksSUFBSTtRQUNOLE9BQU8sSUFBSSxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQzdFLENBQUM7SUFFRDs7T0FFRztJQUNILElBQUksUUFBUTtRQUNWLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUNqQixNQUFNLElBQUksS0FBSyxDQUFDLDBCQUEwQixDQUFDLENBQUM7U0FDN0M7UUFDRCxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7UUFDdEIsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsUUFBUSxDQUFDO0lBQ2pDLENBQUM7SUFFRDs7T0FFRztJQUNILElBQUksR0FBRztRQUNMLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztRQUN0QixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLENBQUM7SUFDNUIsQ0FBQztJQUVEOzs7T0FHRztJQUNILElBQUksWUFBWTtRQUNkLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUNqQixNQUFNLElBQUksS0FBSyxDQUFDLDhCQUE4QixDQUFDLENBQUM7U0FDakQ7UUFDRCxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7UUFDdEIsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsWUFBb0IsQ0FBQztJQUM3QyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsSUFBSSxTQUFTO1FBQ1gsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO1lBQ2pCLE1BQU0sSUFBSSxLQUFLLENBQUMsK0JBQStCLENBQUMsQ0FBQztTQUNsRDtRQUNELElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztRQUN0QixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxTQUFpQixDQUFDO0lBQzFDLENBQUM7SUFFRDs7T0FFRztJQUNILElBQUksSUFBSTtRQUNOLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUNqQixNQUFNLElBQUksS0FBSyxDQUFDLHNCQUFzQixDQUFDLENBQUM7U0FDekM7UUFDRCxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7UUFDdEIsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxDQUFDO0lBQzdCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxJQUFJLE9BQU87UUFDVCxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDakIsTUFBTSxJQUFJLEtBQUssQ0FBQyxnQ0FBZ0MsQ0FBQyxDQUFDO1NBQ25EO1FBRUQsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDO1FBQ3RCLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLE9BQVMsQ0FBQztJQUNsQyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUFJLElBQUk7UUFDTixJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDakIsTUFBTSxJQUFJLEtBQUssQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO1NBQ3pDO1FBQ0QsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDO1FBQ3RCLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLElBQUksQ0FBQztJQUM3QixDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUFJLE1BQU07UUFDUixPQUFPLElBQUksQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLGtCQUFrQixHQUFHLENBQUMsRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsa0JBQWtCLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNqRyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUFJLEdBQUc7UUFDTCxPQUFPLElBQUksQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxrQkFBa0IsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUM3RSxDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUFJLElBQUk7UUFDTixPQUFPLElBQUksQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLGtCQUFrQixDQUFDLENBQUM7SUFDL0MsQ0FBQztJQUVEOztPQUVHO0lBQ0gsSUFBSSxNQUFNO1FBQ1IsT0FBTyxJQUFJLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxrQkFBa0IsRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM3RixDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUFJLGdCQUFnQjtRQUNsQixPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDMUIsQ0FBQztJQTRCRDs7OztPQUlHO0lBQ0gsTUFBTSxDQUFDLFNBQVMsQ0FBQyxJQUFhO1FBQzVCLElBQUksQ0FBQyxJQUFJLEVBQUU7WUFDVCxPQUFPLElBQUksQ0FBQztTQUNiO1FBRUQsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQywyQkFBMkIsQ0FBQyxDQUFDO1FBQ3RELElBQUksQ0FBQyxLQUFLLEVBQUU7WUFDVixPQUFPLElBQUksQ0FBQztTQUNiO1FBRUQsT0FBTyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDbEIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsU0FBUyxDQUFDLFNBQW1CO1FBQzNCLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUNqQixNQUFNLElBQUksS0FBSyxDQUFDLHFDQUFxQyxDQUFDLENBQUM7U0FDeEQ7UUFFRCxPQUFPLElBQUksQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsT0FBTyxTQUFTLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLEtBQUssS0FBSyxDQUFDLENBQUM7SUFDeEcsQ0FBQztJQUVEOzs7Ozs7Ozs7T0FTRztJQUNILE1BQU0sQ0FBQyxhQUEwRixFQUFFLFlBQWtCLEVBQ25ILFlBQWtCOztRQUNsQixNQUFNLEdBQUcsR0FBRyxhQUFhLElBQUksRUFBRSxDQUFDO1FBRWhDLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUNqQixNQUFNLElBQUksS0FBSyxDQUFDLDZCQUE2QixDQUFDLENBQUM7U0FDaEQ7UUFFRCxJQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRXpCLE1BQU0sYUFBYSxHQUFHLElBQUksT0FBTyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUM7YUFDaEUsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUcsQ0FBQyxJQUFNLFFBQUUsSUFBSSxDQUFDLElBQUksQ0FBQywwQ0FBRSxJQUFJLENBQUMsQ0FBQztRQUVqRCxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDNUIsSUFBSSxJQUFJLEVBQUU7WUFDUixhQUFhLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFLLENBQUMsQ0FBQztZQUM5QixhQUFhLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxJQUFNLENBQUMsQ0FBQztZQUN6QyxhQUFhLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxRQUFVLENBQUMsQ0FBQztZQUN4QyxhQUFhLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFTLENBQUMsQ0FBQztTQUM3QztRQUVELGFBQWEsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLFFBQVEsSUFBSSxJQUFJLENBQUMsQ0FBQztRQUU3QyxJQUFJLENBQUMsV0FBVyxDQUFDLGFBQWEsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUVyQyxJQUFJLENBQUMsRUFBRSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDaEMsT0FBTyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLEVBQUUsRUFBRTtZQUNuRCxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDO1lBQ2xCLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQy9CLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxZQUFZLENBQUMsQ0FBQztJQUN0QyxDQUFDO0lBRUQ7Ozs7Ozs7OztPQVNHO0lBQ0gsUUFBUSxDQUFDLGVBQThELEVBQUUsWUFBa0IsRUFDekYsWUFBa0I7UUFDbEIsTUFBTSxHQUFHLEdBQUcsZUFBZSxJQUFJLEVBQUUsQ0FBQztRQUVsQyxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDakIsTUFBTSxJQUFJLEtBQUssQ0FBQywrQkFBK0IsQ0FBQyxDQUFDO1NBQ2xEO1FBRUQsTUFBTSxJQUFJLEdBQUcsR0FBRyxDQUFDLElBQUksSUFBSSxNQUFNLENBQUM7UUFFaEMsTUFBTSxlQUFlLEdBQUcsSUFBSSxPQUFPLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQzthQUNwRSxZQUFZLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFdEIsSUFBSSxDQUFDLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLGVBQWUsRUFBRSxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFakUsT0FBTyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLEVBQUUsRUFBRTtZQUNyRCxJQUFJLENBQUMsRUFBRSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDaEMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDbkMsT0FBTyxRQUFRLENBQUMsTUFBTSxDQUFDO1FBQ3pCLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFO1lBQ1AsSUFBSSxDQUFDLENBQUMsTUFBTSxLQUFLLFVBQVUsQ0FBQyxnQkFBZ0IsRUFBRTtnQkFDNUMsT0FBTyxJQUFJLENBQUM7YUFDYjtZQUNELE1BQU0sQ0FBQyxDQUFDO1FBQ1YsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxZQUFZLENBQUMsQ0FBQztJQUN0QyxDQUFDO0lBRUQ7Ozs7Ozs7O09BUUc7SUFDSCxNQUFNLENBQUMsYUFBbUMsRUFBRSxZQUFrQixFQUFFLFlBQWtCO1FBQ2hGLE1BQU0sR0FBRyxHQUFHLGFBQWEsSUFBSSxFQUFFLENBQUM7UUFFaEMsTUFBTSxhQUFhLEdBQUcsSUFBSSxPQUFPLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3BFLElBQUksQ0FBQyxXQUFXLENBQUMsYUFBYSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBRXJDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFO1lBQ2xCLElBQUksQ0FBQyxFQUFFLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUNqQztRQUVELE9BQU8sSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxFQUFFLEVBQUU7WUFDbkQsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUU7Z0JBQ2xCLE9BQU8sSUFBSSxDQUFDO2FBQ2I7WUFFRCxPQUFRLFFBQVEsQ0FBQyxNQUFtQixDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsSUFBSSxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1FBQ2pGLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsWUFBWSxDQUFDLENBQUM7SUFDdEMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSyxtQkFBbUIsQ0FBQyxXQUF1Qzs7UUFDakUsSUFBSSxJQUFZLENBQUM7UUFDakIsSUFBSSxXQUFXLENBQUMsSUFBSSxFQUFFO1lBQ3BCLElBQUksR0FBRyxXQUFXLENBQUMsSUFBSSxDQUFDO1NBQ3pCO2FBQU07WUFDTCxNQUFNLE1BQU0sR0FBRyxlQUFlLENBQUMsV0FBVyxDQUFDLE1BQU0sSUFBSSxNQUFNLENBQUMsQ0FBQztZQUM3RCxJQUFJLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO2dCQUNyQixNQUFNLElBQUksS0FBSyxDQUFDLHdCQUF3QixNQUFNLEVBQUUsQ0FBQyxDQUFDO2FBQ25EO1lBRUQsTUFBTSxJQUFJLEdBQUcsV0FBVyxDQUFDLElBQUksV0FBSyxXQUFXLGFBQVgsV0FBVyx1QkFBWCxXQUFXLENBQUUsSUFBWSwwQ0FBRSxJQUFJLENBQUEsSUFBSSxJQUFJLEVBQUUsQ0FBQztZQUM1RSxJQUFJLEdBQUcsTUFBTSxHQUFHLElBQUksQ0FBQztTQUN0QjtRQUVELCtCQUErQjtRQUMvQixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEtBQUssR0FBRyxFQUFFO1lBQzFCLElBQUksR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDO1NBQ25CO1FBRUQsc0JBQXNCO1FBQ3RCLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUNoRCxNQUFNLElBQUksS0FBSyxDQUFDLGlCQUFpQixJQUFJLEVBQUUsQ0FBQyxDQUFDO1NBQzFDO1FBRUQsT0FBTyxXQUFXLEdBQUcsSUFBSSxDQUFDO0lBQzVCLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILFdBQVcsQ0FBQyxHQUFZLEVBQUUsT0FBNEI7UUFDcEQsSUFBSSxPQUFPLENBQUMsS0FBSyxFQUFFO1lBQ2pCLE9BQU87U0FDUjtRQUVELE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUM1QixJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsWUFBWSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQy9DLEdBQUcsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDckIsT0FBTztTQUNSO1FBRUQsR0FBRyxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxZQUFvQixDQUFDLENBQUM7UUFDakQsR0FBRyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBTSxDQUFDLENBQUM7SUFDM0IsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCxZQUFZLENBQUMsT0FBK0IsRUFBRSxZQUFrQixFQUFFLFlBQWtCO1FBQ2xGLE1BQU0sR0FBRyxHQUFHLE9BQU8sSUFBSSxFQUFFLENBQUM7UUFFMUIsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO1lBQ2pCLE1BQU0sSUFBSSxLQUFLLENBQUMsNEJBQTRCLENBQUMsQ0FBQztTQUMvQztRQUVELE1BQU0sR0FBRyxHQUFHLElBQUksT0FBTyxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUMvRCxJQUFJLENBQUMsRUFBRSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNyRCxPQUFPLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLFFBQVEsRUFBRSxFQUFFO1lBQ3pDLGtGQUFrRjtZQUNsRixJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUNuQyxPQUFPLElBQUksQ0FBQztRQUNkLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFO1lBQ1AsSUFBSSxDQUFDLENBQUMsTUFBTSxLQUFLLFVBQVUsQ0FBQyxnQkFBZ0IsRUFBRTtnQkFDNUMsT0FBTyxJQUFJLENBQUM7YUFDYjtZQUNELE1BQU0sQ0FBQyxDQUFDO1FBQ1YsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxZQUFZLENBQUMsQ0FBQztJQUN0QyxDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNILFlBQVksQ0FBQyxPQUE2QixFQUFFLFlBQWtCLEVBQUUsWUFBa0I7UUFDaEYsTUFBTSxHQUFHLEdBQUcsT0FBTyxJQUFJLEVBQUUsQ0FBQztRQUUxQixNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDM0IsTUFBTSxHQUFHLEdBQUcsSUFBSSxPQUFPLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDO2FBQzlELE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUVoQixJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUUzQixPQUFPLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLFFBQVEsRUFBRSxFQUFFO1lBQ3pDLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQy9CLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxZQUFZLENBQUMsQ0FBQztJQUN0QyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILGNBQWMsQ0FBQyxPQUFnQztRQUM3QyxNQUFNLEVBQUUsSUFBSSxFQUFFLElBQUksS0FBa0IsT0FBTyxFQUFwQixRQUFRLFVBQUssT0FBTyxFQUFyQyxnQkFBMkIsQ0FBVSxDQUFDO1FBRTVDLElBQUksQ0FBQyxJQUFJLEVBQUU7WUFDVCxPQUFPO1NBQ1I7UUFFRCxXQUFXO1FBQ1gsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxDQUFDO1FBRTVCLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLElBQUksU0FBUyxDQUFDO1FBQzFELElBQUksQ0FBQyxRQUFRLGlDQUFNLFFBQVEsS0FBRSxRQUFRLElBQUcsQ0FBQztJQUMzQyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxhQUFhLENBQUMsT0FBZ0M7UUFDNUMsTUFBTSxFQUFFLFFBQVEsRUFBRSxHQUFHLE9BQU8sQ0FBQztRQUM3QixJQUFJLFFBQVEsRUFBRTtZQUNaLE9BQU8sUUFBUSxDQUFDO1NBQ2pCO1FBRUQsSUFBSSxPQUFPLElBQUksS0FBSyxXQUFXLElBQUksT0FBTyxDQUFDLElBQUksWUFBWSxJQUFJLEVBQUU7WUFDL0QsT0FBTyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztTQUMxQjtRQUVELElBQUksT0FBTyxDQUFDLElBQUksS0FBSyxVQUFVLElBQUksT0FBTyxPQUFPLENBQUMsSUFBSSxLQUFLLFFBQVEsRUFBRTtZQUNuRSxNQUFNLEtBQUssR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQywyQkFBMkIsQ0FBQyxDQUFDO1lBQzlELE9BQU8sS0FBSyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUMxQjtRQUVELE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVEOztPQUVHO0lBQ0ssV0FBVyxDQUFDLE9BQW1DO1FBQ3JELElBQUksQ0FBQyxRQUFRLENBQUM7WUFDWixJQUFJLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDO1lBQ2xDLFlBQVksRUFBRSxPQUFPLENBQUMsZUFBZSxDQUFDO1lBQ3RDLFNBQVMsRUFBRSxPQUFPLENBQUMsbUJBQW1CLENBQUM7WUFDdkMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxjQUFjLENBQUM7WUFDakMsR0FBRyxFQUFFLE9BQU8sQ0FBQyxZQUFZLENBQUMsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUMvRCxJQUFJLEVBQUUsQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDO1lBQzdCLE9BQU8sRUFBRSxPQUFPLENBQUMsdUJBQXVCLENBQUMsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO1NBQzFGLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSCxRQUFRLENBQUMsSUFBNEI7UUFDbkMsTUFBTSxFQUFFLEVBQUUsRUFBRSxHQUFHLElBQWUsQ0FBQztRQUMvQixJQUFJLEVBQUUsSUFBSSxJQUFJLENBQUMsRUFBRSxLQUFLLEVBQUUsRUFBRTtZQUN4QixNQUFNLElBQUksS0FBSyxDQUFDLGdCQUFnQixJQUFJLENBQUMsRUFBRSxxQ0FBcUMsRUFBRSxFQUFFLENBQUMsQ0FBQztTQUNuRjtRQUVELE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUM7UUFFbEMsSUFBSSxHQUFHLENBQUM7UUFDUixJQUFJLElBQUksQ0FBQyxHQUFHLFlBQVksR0FBRyxFQUFFO1lBQzNCLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDO1NBQ2hCO2FBQU07WUFDTCxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsSUFBSSxJQUFJLEdBQUcsRUFBRSxDQUFDO1lBQzVCLElBQUksSUFBSSxDQUFDLEdBQUcsRUFBRTtnQkFDWixHQUFHLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxHQUFjLENBQUMsQ0FBQzthQUNuQztTQUNGO1FBRUQsNERBQTREO1FBQzVELElBQUksQ0FBQyxRQUFRLENBQUMsbUNBQ1QsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUNqQixRQUFRLEVBQUUsSUFBSSxDQUFDLFFBQWtCLEVBQ2pDLFlBQVksRUFBRSxDQUFDLElBQUksQ0FBQyxZQUFZLElBQUksSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQXNCLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxZQUFZLEVBQy9GLFNBQVMsRUFBRSxDQUFDLElBQUksQ0FBQyxTQUFTLElBQUksSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQW1CLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxTQUFTLEVBQ25GLElBQUksRUFBRSxJQUFJLENBQUMsSUFBYyxJQUFJLElBQUksQ0FBQyxJQUFJLEVBQ3RDLEdBQUcsRUFDSCxJQUFJLEVBQUUsT0FBTyxJQUFJLENBQUMsSUFBSSxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUUsSUFBZ0IsQ0FBQyxhQUF1QixFQUMzRixPQUFPLEVBQUUsSUFBSSxDQUFDLE9BQXFDLElBQUksSUFBSSxDQUFDLE9BQU8sSUFBSSxFQUFFLEdBQzFFLENBQUM7SUFDSixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsTUFBTTs7UUFDSixJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7UUFDdEIsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBRTVCLE9BQU87WUFDTCxFQUFFLEVBQUUsSUFBSSxDQUFDLEVBQUU7WUFDWCxRQUFRLEVBQUUsSUFBSSxDQUFDLFFBQVE7WUFDdkIsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJO1lBQ2YsR0FBRyxRQUFFLElBQUksQ0FBQyxHQUFHLDBDQUFFLE1BQU0sRUFBRTtZQUN2QixJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUk7WUFDZixZQUFZLEVBQUUsSUFBSSxDQUFDLFlBQVksSUFBSyxJQUFJLENBQUMsWUFBcUIsQ0FBQyxXQUFXLEVBQUU7WUFDNUUsU0FBUyxFQUFFLElBQUksQ0FBQyxTQUFTLElBQUssSUFBSSxDQUFDLFNBQWtCLENBQUMsV0FBVyxFQUFFO1lBQ25FLE9BQU8sRUFBRSxJQUFJLENBQUMsT0FBTztTQUNYLENBQUM7SUFDZixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsY0FBYztRQUNaLElBQUksQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLEVBQUU7WUFDMUIsTUFBTSxJQUFJLGVBQWUsQ0FBQyx3QkFBd0IsSUFBSSxDQUFDLEVBQUUsb0JBQW9CLENBQUMsQ0FBQztTQUNoRjtJQUNILENBQUM7Q0FDRjtLQWxoQlUsSUFBSSJ9